
\chapter{Praktische uitwerking}
\vspace{-3cm}
Het annoteren van afbeeldingen is \'{e}\'{e}n van de onderdelen binnen de \textit{Profile Manager} van CX Social. De \textit{Profile Manager} is een nieuwe feature die gebruikers moet helpen bij het beheren van hun sociale media profielen. Een thema kan aangemaakt worden voor Facebook of Twitter die een omslag-en/of profielfoto bevatten. Eens een omslagfoto ge\"{u}pload is, is het mogelijk om annotaties toe te voegen. Dit kan simpelweg tekst zijn maar ook performantie indicatoren kunnen op de afbeelding geplaatst worden. Gebruikers kunnen voor geconnecteerde profielen instellen welk thema op welk tijdstip actief moet zijn. De aangemaakte afbeeldingen worden dan op de ingestelde tijdstippen ge\"{u}pload naar het juiste profiel. 


\section{Frontend implementatie}
\subsection{Creatie van een thema}
Een groot deel van de frontend code van CX Social is geschreven met React. Met React kunnen makkelijk componenten aangemaakt worden om zo complexe interfaces aan te maken. %2o zijn er heel wat componenten beschikbaar waarmee gemakkelijk functionaliteit aan een pagina kan toegevoegd worden.
Eens een thema aangemaakt is, kan het later ook aangepast worden. Omdat dezelfde functionaliteit op twee verschillende pagina's nodig is, wordt hiervoor een React component aangemaakt: de \lstinline{Theme} component. Bij het aanmaken van de component dienen enkele eigenschappen meegegeven te worden. Eerst en vooral wordt het, uit de databank opgehaalde, thema meegegeven indien dit beschikbaar is. %ADD SOME INFO OVER HOW IT IS IN VIEW, WHEN NO THEME IS SELECTED!
Het account \textit{Identity Document} (ID), \textit{Cross-site requrest forgery} (CSRF) token, beschikbare services, en de annotatiepermissie zijn verplichte eigenschappen van de component. Deze eigenschappen zullen nooit veranderen tijdens de levensduur van het component, het zijn dus constanten. Het CSRF token wordt aan het formulier toegevoegd om ongeauthoriseerde acties in applicaties te voorkomen. Met het token wordt ervoor gezorgd dat geen ongeldige \textit{requests} gemaakt kunnen worden. %http://stackoverflow.com/questions/5207160/what-is-a-csrf-token-what-is-its-importance-and-how-does-it-work
Niet elke gebruiker heeft dezelfde rechten in CX Social. Binnen een bepaald plan zijn verschillende gebruikersrollen beschikbaar. Zo zijn er gewone gebruikers, \textit{admins}, managers, \textit{editors}, \textit{contributors} en \textit{analytics users}, elk met hun eigen rechten. Permissies, die aan de gebruiker werden toegekend, worden meegegeven aan de Theme component om de annoteer \textit{feature} al dan niet beschikbaar te stellen. Ieder inputveld bevat een \lstinline{onChange} event waarmee veranderingen afgehandeld kunnen worden. Zoals te zien in het codevoorbeeld 8888REFERENCE VOORBEELD8888 wordt de state van de component ge\"{u}pdatet wanneer een verandering aan de inputvelden plaatsvindt. De state van de component kan, in tegenstelling tot de eigenschappen (props), wel veranderen binnen het component. De state kan aangepast worden met behulp van  de \lstinline{setState()} methode. 

\begin{lstlisting}[caption={Theme component - Dropdown}\label{ThemeComponentDropdown},language=javascript]
<select className={this.state.saving && this.state.service === '' ? 'error 		fieldset-input' : 'fieldset-input'} id="service" name="service" ref="service" value={this.getService()}
	onChange={function (event) {
		this.setState({service: event.target.value});
	}.bind(this)}>
	{this.props.services.map(function (service) {
		return <option key={service} value={service}>{this.capitalize(service)}</option>
	}.bind(this))}
</select>
\end{lstlisting}

Naast het ingeven van een naam en \textit{service} voor het thema, kunnen ook een omslag-en profielfoto toegevoegd worden. Het uploaden van de afbeeldingen wordt afgehandeld door een reeds bestaande component. Deze zal een, door de gebruiker geselecteerde, foto uploaden naar de \textit{fileserver} en op de pagina weergeven. Eens een afbeelding aanwezig is, is het mogelijk om annotaties toe te voegen. Om een afbeelding te annoteren wordt een pop-upvenster geopend. Aangezien deze pop-up een volledig nieuwe \textit{template}is, dienen enkele eigenschappen van het thema meegegeven te worden. Als parameters in de URL worden zowel de \textit{service} als de bestandsnaam van de afbeelding op de fileserver meegegeven. Beide parameters zijn nodig om het canvas op te stellen. De \textit{service} bepaald immers de dimensies van het canvas aangezien deze verschillen voor zowel Facebook als Twitter. Via de bestandsnaam kan de correcte afbeelding ingeladen worden in het pop-upvenster.

Zoals reeds besproken in sectie \ref{vergelijkingBibliotheken}, lijkt Fabric.js de beste keuze te zijn om dit project uit te werken. Aangezien niet alle functionaliteit van deze bibliotheek van toepassing zijn op dit project, wordt een \textit{custom build} aangemaakt. Deze bevat de tekst, interactieve tekst, animatie, serialisatie, interactie en node \textit{features}. Bij het openen van het pop-upvenster wordt het \lstinline{ThemeAnnotations} component ge\"{i}nitialiseerd met de nodige eigenschappen. Deze zijn het account ID, de bestandsnaam van de afbeelding, de \textit{service} en een kleurenpallet. Tussen deze kleuren en eender welke hexadecimale waarde kan gekozen worden tijdens het stylen van de annotaties.

\begin{lstlisting}[caption={ThemeAnnotations component - initialisatie}\label{ThemeComponentDropdown},language=javascript]
$(document).ready(function() {
	var annotationProps = {
		accountId: '{{account.id}}',
		image: '{{image}}',
		service: '{{service}}',
		colors:  [
		"#FF691F",
		"#FAB81E",
		"#7FDBB6",
		"#19CF86"
		]};
		
	Engagor.App.renderer.render(
		React.createElement(ThemeAnnotations, annotationProps),
		document.getElementById('annotations'),
		$.noop()
	);
});
\end{lstlisting}

\subsection{Annoteren van de afbeelding}\label{AnnoterenVanAfbeelding}
Wanneer het element aanwezig is in het DOM, wordt het canvas ge\"{i}nitialiseerd. Dit gebeurt in de \lstinline{componentDidMount()} functie van de React component. Zowel Facebook als Twitter verwachten omslagfoto's van een bepaalde resolutie. Wordt hier niet aan voldaan, zullen de foto's worden geschaald. Om kwaliteitsverlies te voorkomen, worden de foto's dus best in volle resolutie g\"{u}pload. Helaas kan het canvas niet aangemaakt worden met de originele dimensies van de foto's. Bij Facebook zou dit een canvas van 828 op 315 pixels zijn terwijl dit voor Twitter een canvas van 1500 op 500 pixels zou zijn. Het is helemaal niet handig voor een gebruiker om op een canvas met een breedte van 1500 pixels te werken. Daarom worden de dimensies van het canvas dynamisch berekend. Dankzij de berekeningen kan ook de ratio (hoogte ten opzichte van breedte) van de afbeeldingen behouden worden. Wanneer de afbeelding dan uiteindelijk gegenereerd wordt, moeten de dimensies simpelweg met dezelfde verkleiningsfactor vermenigvuldigd worden om zo een afbeelding met gewenste dimensies te bereiken. Het canvas wordt als volgt aangemaakt:

\begin{lstlisting}[language=javascript]
getInitialState: function () {
	return {
		facebookCover: {width: '828', height: '315'},
		twitterCover: {width: '1500', height: '500'}
	}
},
componentDidMount: function () {
	var dimensions = {};
	if (this.props.service === 'twitter') {
		ratio = this.state.twitterCover.width / this.state.twitterCover.height;
		dimensions = this.state.twitterCover;
	}
	else if (this.props.service === 'facebook') {
		ratio = this.state.facebookCover.width / this.state.facebookCover.height;
		dimensions = this.state.facebookCover;
	}
		
	this.canvas = new fabric.Canvas('annotationCanvas', {
		width: this.refs.container.offsetWidth,
		height: this.refs.container.offsetWidth / ratio,
		preserveObjectStacking: true,
		renderOnAddRemove: true,
		multiply: ratio,
		service: this.props.service,
		dimensions: dimensions,
	});
}
\end{lstlisting}

Eens het canvas bestaat, kunnen objecten toegevoegd worden. Met behulp van de \lstinline{fromUrl(url, callback)} methode van het \textit{Image} object kan een afbeelding aan het canvas toegevoegd worden. De URL wordt simpelweg opgesteld aan de hand van de meegegeven bestandsnaam. Eens de afbeelding ingeladen is worden enkele transformaties uitgevoerd om de afbeelding gepast weer te geven. Zo wordt de afbeelding gecentreerd, geschaald tot de volledige breedte van het canvas en naar de achtergrond van het canvas geplaatst. Deze transformaties zorgen ervoor dat het volledige canvas bedekt wordt door de afbeelding en dat alle andere objecten, zoals tekst en KPI's, bovenop de afbeelding terecht zullen komen. ZIE BIJLAGE HANDLEANNOTATIONS FUNCTION VANAF REGEL ..... (gwn inladen van afbeelding)

Gewone tekst wordt als een \lstinline{IText} object toegevoegd aan het canvas. Hierdoor is de gebruiker in staat om de tekst aan te passen in het canvas zelf en hoeft dus geen extra inputveld te worden voorzien. Een tekst object wordt als volgt aan het canvas toegevoegd:

\begin{lstlisting}[language=javascript]
var text = new fabric.IText('click here to add your text', {
	fontFamily: 'Arial',
	left: this.canvas.width / 2,
	top: this.canvas.height / 2,
	fontSize: 30,
	transparentCorners: false,
	textAlign: 'left',
	lockUniScaling: true,
	borderColor: '#00b4d0',
	cornerColor: '#00b4d0',
	centeredScaling: true,
	textType: 'text',
});

this.canvas.add(text);
this.canvas.bringToFront(text);
\end{lstlisting}

Naast de standaard eigenschappen zoals tekstgrootte, lettertype en positie op het canvas bevat het object een extra \lstinline{textType} eigenschap. Deze maakt duidelijk dat het om gewoon tekst object gaat en niet over een KPI. Na het toevoegen van het object aan het canvas wordt het naar de voorgrond gebracht om er zeker van te zijn dat de tekst bovenop de afbeelding terecht komt. 

De gebruiker kan kiezen tussen vier verschillende soorten KPI's: respons tijdens het laatste uur, respons tijdens de laatste dag, geholpen gebruikers de laatste dag en geholpen gebruikers de laatste zeven dagen. Bij het toevoegen van een KPI aan het canvas moet het soort KPI dus ook opgeslagen worden.% Ook dient een waarde toegekend te worden zodat de gebruiker een idee heeft van de uiteindelijke afbeelding. 
Wat een probleem vormde tijdens de uitwerking was de positionering van de KPI's. Aangezien dit variabele getallen zijn, is een getal van vier of vijf cijfers lang niet uit te sluiten. Hoewel de inhoud van een \lstinline{IText} object uit te lijnen is (links, rechts of gecenteerd), is dit pas merkbaar bij tekst bestaande uit meerdere lijnen. Daarom wordt geopteerd voor een \lstinline{Textbox} object om de KPI's weer te geven. Tijdens het initialiseren van dit object kan de breedte ingesteld worden waardoor ook een enkel woord uitgelijnd kan worden. Via een \textit{switch} statement wordt de correcte type KPI aan het object toegekend (zie onderstaand code fragment). 

\begin{lstlisting}[language=javascript]
var mockValue = '';
switch (value) {
	case 'last_hour_response_time':
		mockValue = '12';
		break;
	case 'last_day_response_time':
		mockValue = '30';
		break;
	case 'seven_days_serviced_users':
		mockValue = '218';
		break;
	case 'last_day_serviced_users':
		mockValue = '72';
		break;
	default:
		mockValue = 'NaN'
}

var KPI = new fabric.Textbox(mockValue, {
	fontFamily: 'Arial',
	left: this.canvas.width / 2,
	top: this.canvas.height / 2,
	fontSize: 70,
	textAlign: 'center',
	textType: 'kpi',
	kpiType: value,
	width: 400,
	editable: false
});

this.canvas.add(KPI);
this.canvas.bringToFront(KPI);
\end{lstlisting}

%MAYBE DELETE
Gebruikers zijn ook in staat om een \textit{template} te gebruiken. Dit zal enkele tekst objecten op het canvas plaatsen alsook de gekozen KPI. Alle elementen worden gecentreerd op het canvas en kunnen door de gebruiker zelf nog aangepast worden. 
% De \lstinline{lockUniScaling} eigenschap zal ervoor zorgen <- zet bij bespreken van scalen!

\subsection{Teksteditor????}
\"{E}\"{e}n van de \textit{features} tijdens het annoteren van een afbeelding is het stylen van de tekst. Zo is het mogelijk eigenschappen zoals tekstgrootte, lettertype, kleur en gewicht (vet of schuin) aan te passen. Om dit op een modulaire manier te verwezenlijken, wordt gebruik gemaakt van een React component. Aan de \lstinline{TextEditor} component worden enkele eigenschappen meegegeven om een bestaand tekst object aan te kunnen passen. Onder deze eigenschappen valt een \lstinline{onChange()} functie, een \lstinline{currentSettings} object en een \lstinline{selectedColor} string. Wanneer een object in het canvas wordt geselecteerd, wordt het  \lstinline{object:selected} event getriggered. In de \textit{handler} van dit event wordt, na confirmatie dat het om een tekst object gaat, de state van de \lstinline{Theme} component aangepast naar de huidige instellingen van het object: 

\begin{lstlisting}[language=javascript]
this.canvas.on({'object:selected': function () {
	var object = null;
	if (this.isTextSelected()) {
		object = this.canvas.getActiveObject();

		this.setState({
			currentSettings: {
				fontSize: object.getFontSize(),
				fontWeight: object.getFontWeight(),
				fontFamily: object.getFontFamily(),
				fontStyle: object.getFontStyle(),
				fontColor: object.getFill(),
				textAlign: object.getTextAlign(),
			}, textSelected: true, objectInfo: kpiType
		});
	}}.bind(this)
});
\end{lstlisting}
~\ref{lst:ThemeComponentTextEditor}
De update van de state zal ervoor zorgen dat de component opnieuw gerendered wordt. Met behulp van een check in de \lstinline{render} functie van de \lstinline{Theme} component kan de \lstinline{TextEditor} component ge\"{i}nitialiseerd worden met de nodige eigenschappen [\ref{lst:ThemeComponentTextEditor}]. De belangrijkste eigenschap is de \lstinline{onChange()} functie die vanuit de \lstinline{TextEditor} component getriggered kan worden. Het triggeren gebeurt wanneer een inputveld van de editor verandert. De huidige instellingen worden opgehaald en de nodige aanpassingen worden gemaakt. Uiteindelijk wordt de state aangepast en wordt de \lstinline{onChange()} functie aageroepen met de nieuwe instellingen als parameter [\ref{lst:TextEditorComponentBold}]. Bij het triggeren van de \lstinline{onChange()} zal het geselecteerde object in de \lstinline{Theme} component aangepast worden met de nieuwe instellingen. Hierna wordt de \lstinline{renderAll()} functie van het Fabric.js canvas aangeroepen om de aangepassingen op het canvas te tonen [\ref{lst:ThemeComponentTextEditor}].

\begin{lstlisting}[caption={Theme component - Text editor},label=lst:ThemeComponentTextEditor,language=javascript]
<TextEditor onChange={function (value) {
	if (this.isTextSelected()) {
		var object = this.canvas.getActiveObject();
		object.setFontWeight(value.fontWeight);
		object.setFontSize(value.fontSize);
		object.setFontStyle(value.fontStyle);
		object.setFontFamily(value.fontFamily);
		object.setTextAlign(value.textAlign);
		this.canvas.renderAll();
	}}.bind(this)}
	currentSettings={this.getActiveObjectSettings()}
	selectedColor={this.getActiveObjectSettings().fontColor}
	colors={this.props.colors}>
</TextEditor>
\end{lstlisting}

\begin{lstlisting}[caption={TextEditor component - toggle bold},label=lst:TextEditorComponentBold,language=javascript]
<li>
	<a className={this.getCurrentSettings().fontWeight === 'bold' ? 'button primary' : 'button'}
		onClick={function () {
		var settings = this.getCurrentSettings();
		settings.fontWeight = (settings.fontWeight === 'bold') ? 'normal' : 'bold';
		this.setState({currentSettings: settings});
		this.props.onChange(settings);
	}.bind(this)}>B</a>
</li>
\end{lstlisting}

// THEME DISPATCHER???

\subsection{Schalen van tekst????}
Objecten in het canvas kunnen onmiddellijk verplaatst, geschaald en geroteerd worden met Fabric.js. Zo kan de gebruiker zeer gemakkelijk de achtergrond afbeelding naar wens manipularen. Enkel het schalen van tekst en KPI's vormt een probleem. Wanneer een tekst object namelijk geschaald wordt, wordt de lettergrootte niet aangepast. Het schalen zorgt er enkel voor dat er als het ware wordt ingezoomd op het object zelf. Tijdens het ontwerpen van een canvas (clientside) vormt dit geen probleem maar wanneer de afbeelding moet gegenereerd worden in de backend kan dit problematisch zijn. Alle eigenschappen van het object (hoogte, breedte, positie) zullen namelijk ook met dezelfde schaalfactor vermenigvuldigd worden. Wanneer de positionering dan nog eens vermenigvuldigd wordt met de ratio (zie \ref{AnnoterenVanAfbeelding}), kan het voorkomen dat enkele negatieve waarden bekomen worden. Dit vormt vooral een probleem wanneer tekst op de uitersten van het canvas (dus bijvoorbeeld in hoekpunten) geplaatst wordt. 

Om dit te voorkomen wordt ervoor gezorgd dat tekst in het canvas op een andere manier schaalt. Door gebruik te maken van het \lstinline{object:scaling} event wordt de tekstgrootte aangepast in plaats van de schaal van het object (zie \ref{lst:ThemeAnnotationsScalingText}). Bij het triggeren van het event wordt gekeken of het wel degelijk om een tekst object gaat (de afbeelding kan immers normaal geschaald worden). Daarna wordt de huidige tekstgrootte vermenigvuldigd met de horizontale schalingsfactor (merk op: de horizontale schalingsfactor wordt gebruikt omdat de \lstinline{lockUniScaling} eigenschap van het object actief is waardoor zowel x-als y-as met dezelfde factor geschaald worden). Uiteindelijk wordt de tekstgrootte afgerond naar een geheel getal omdat pixels als eenheid gebruikt worden. Zowel de horizontale als verticale schaal wordt opnieuw op 1 geplaatst om eerder beschreven probleem met schaling te voorkomen. 

\begin{lstlisting}[caption={ThemeAnnotations component - text scaling},label=lst:ThemeAnnotationsScalingText,language=javascript]
this.canvas.on('object:scaling', function (e) {
	if (e.target && this.isTextSelected()) {
		e.target.fontSize *= e.target.scaleX;
		e.target.fontSize = e.target.fontSize.toFixed(0);
		e.target.scaleX = 1;
		e.target.scaleY = 1;
		
		this.setState({
			currentSettings: {
			fontSize: e.target.getFontSize(),
			fontWeight: e.target.getFontWeight(),
			fontFamily: e.target.getFontFamily(),
			fontStyle: e.target.getFontStyle(),
			fontColor: e.target.getFill(),
			textAlign: e.target.getTextAlign()}
		});
	}
}.bind(this));
\end{lstlisting}

\subsection{Verwijderen van objecten en groepen???? MSS WEGLATEN?}
Naast het toevoegen van tekst moet de gebruiker in staat zijn om tekst te verwijderen. De Fabric.js bibliotheek bezit hiervoor reeds de benodigde functionaliteit. Via de \lstinline{remove()} functie van het canvas, kan een object van het canvas verwijdert worden. Gebruikers mogen niet in staat zijn om de afbeelding te verwijderen dus moet eerst bepaald worden of de geselecteerde objecten wel degelijk tekst objecten zijn. Wanneer slechts \'{e}\'{e}n object geselecteerd wordt, is dit eenvoudig te verwezenlijken. Moeilijker wordt het wanneer meerdere objecten geselecteerd worden. Hiervoor moeten alle objecten in de actieve groep (de geselecteerde objecten) overlopen worden. Wanneer het type van de objecten overeen komt met deze van tekst, kan het object verwijdert worden. 

\begin{lstlisting}[caption={ThemeAnnotations component - delete group},label=lst:ThemeAnnotationsDeleteGroup,language=javascript]
if (this.canvas.getActiveGroup()) {
	var objectsInGroup = this.canvas.getActiveGroup().getObjects();
	objectsInGroup.forEach(function (object) {
		if (object.type === 'i-text' || object.type === 'textbox') {
			this.canvas.remove(object);
		}
	}.bind(this));
}
\end{lstlisting}

\subsection{Importeren van bestaande annotaties??????!!!?????}
Logischerwijze kan een thema later aangepast worden. Vanuit de databank wordt alle informatie van het thema aan de \lstinline{Theme} component meegegeven. Om de annotaties aan te passen, moeten deze dus vanuit de \lstinline{Theme} component doorgestuurd worden naar het pop-upvenster, de \lstinline{ThemeAnnotations} component. In eerste instatie lijkt de eenvoudigste oplossing om alle vereiste informatie van het thema mee te geven als URL parameters aan de pop-up. Dit vormt geen probleem voor de bestandsnaam van de afbeelding en de service maar het doorsturen van JSON data in de URL kan voor problemen zorgen. Hoewel geen limiet staat op de lengte van een URL ( -> RFC7230) BLABLABLA %https://tools.ietf.org/html/rfc7230#section-3.1.1

ThemeDispatcher....


\subsection{Exporteren van het canvas????}


% Kleur selecteren mss?
% Limitation bars







Deze \textit{Theme} component heeft inputvelden om het thema een naam en een service (Facebook of Twitter) in te geven. 



\section{Backend implementatie}
